// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/microsoft/go-infra/executil"
	"github.com/microsoft/go-infra/subcmd"
)

func init() {
	subcommands = append(subcommands, subcmd.Option{
		Name:    "rebase",
		Summary: "Run 'git rebase -i' on the commits created by 'apply'.",
		Description: `

This command rebases the commits applied to the submodule based on patch files. It uses the HEAD
commit recorded by "apply" as the base commit.

You can use this command to apply fixup and squash commits generated by the "git commit" args
"--fixup" and "--squash". To do this, configure Git using "git config --global rebase.autoSquash 1"
before running this command.

With the -shell flag, this opens an interactive terminal session in the submodule directory and
automatically starts 'git rebase -i'. When you exit the terminal, it automatically runs 'git go-patch extract'
to save your changes back to patch files.

Be aware that editing earlier patch files may cause conflicts with later patch files.
` + repoRootSearchDescription,
		Handle: handleRebase,
	})
}

func handleRebase(p subcmd.ParseFunc) error {
	shell := flag.Bool("shell", false, "Open an interactive shell in the submodule and automatically start 'git rebase -i'. When you exit, automatically runs 'git go-patch extract'.")
	skipExtract := flag.Bool("skip-extract", false, "When using -shell, skip automatic extraction when exiting the shell session.")

	if err := p(); err != nil {
		return err
	}

	config, err := loadConfig()
	if err != nil {
		return err
	}
	_, goDir := config.FullProjectRoots()

	since, err := readStatusFile(config.FullPrePatchStatusFilePath())
	if err != nil {
		return fmt.Errorf("no pre-patch status found - run 'git go-patch apply' first: %w", err)
	}

	if *shell {
		// Check if we're already in a git-go-patch shell session (only for -shell mode)
		if os.Getenv("GIT_GO_PATCH_INTERACTIVE") != "" {
			return fmt.Errorf("already in a git-go-patch interactive shell session - exit the current session first")
		}

		// Check if git is already in a rebase state
		if err := checkForOngoingGitOperations(goDir); err != nil {
			return err
		}

		return handleInteractiveShell(goDir, since, *skipExtract)
	}

	// Original rebase behavior√•
	cmd := exec.Command("git", "rebase", "-i", since)
	cmd.Stdin = os.Stdin
	cmd.Dir = goDir

	if err := executil.Run(cmd); err != nil {
		return err
	}

	warnIfOutsideSubmodule(goDir)
	return nil
}

func handleInteractiveShell(goDir, since string, skipExtract bool) error {
	fmt.Printf("Starting interactive shell session in submodule directory: %s\n", goDir)
	fmt.Printf("Base commit for rebase: %s\n", since)
	fmt.Printf("\n%s=== GIT GO-PATCH SHELL MODE ===%s\n",
		"\033[1;32m", "\033[0m") // Green bold text with reset
	fmt.Printf("\nYou are now in a nested shell session. The prompt shows '(git-go-patch)' to remind you.\n")
	fmt.Printf("\nWorkflow:\n")
	fmt.Printf("  - An interactive rebase will start automatically\n")
	fmt.Printf("  - Complete the rebase process (edit commits, resolve conflicts, etc.)\n")
	fmt.Printf("  - Optionally run 'code .' to open VS Code in the submodule context\n")
	fmt.Printf("  - Use any other git commands as needed\n")
	fmt.Printf("  - When done, type 'exit' to return to the main session\n")
	fmt.Printf("  - To skip extraction, exit with a non-zero code: 'exit 1'\n")

	if !skipExtract {
		fmt.Printf("\nWhen you exit successfully (exit code 0), 'git go-patch extract' will run automatically.\n")
		fmt.Printf("Exit with a non-zero code (e.g., 'exit 1') to skip automatic extraction.\n")
		fmt.Printf("Use --skip-extract flag if you want to disable extraction regardless of exit code.\n")
	} else {
		fmt.Printf("\nAutomatic extraction is disabled via --skip-extract flag.\n")
		fmt.Printf("You'll need to run 'git go-patch extract' manually when ready.\n")
	}

	fmt.Printf("\n%s=== Press Enter to continue ===%s\n", "\033[1;33m", "\033[0m") // Yellow text
	_, _ = fmt.Scanln()                                                            // Wait for user to press Enter

	// Determine the user's shell based on OS
	var userShell string
	if runtime.GOOS == "windows" {
		userShell = os.Getenv("COMSPEC")
		if userShell == "" {
			userShell = "cmd.exe" // Default Windows shell
		}
	} else {
		userShell = os.Getenv("SHELL")
		if userShell == "" {
			userShell = "/bin/bash" // Default Unix shell
		}
	}

	// Create a modified environment
	env := os.Environ()

	// On Unix systems, update PS1 to show git-go-patch indicator
	if runtime.GOOS != "windows" {
		// Find and update PS1, or add it if it doesn't exist
		ps1Updated := false
		for i, envVar := range env {
			if strings.HasPrefix(envVar, "PS1=") {
				// Extract the current PS1 value
				currentPS1, _ := strings.CutPrefix(envVar, "PS1=")
				// Prepend our indicator
				newPS1 := fmt.Sprintf("PS1=(git-go-patch) %s", currentPS1)
				env[i] = newPS1
				ps1Updated = true
				break
			}
		}

		// If PS1 wasn't found in environment, add a default one
		if !ps1Updated {
			env = append(env, "PS1=(git-go-patch) \\u@\\h:\\w\\$ ")
		}
	} else {
		// On Windows, update the PROMPT environment variable
		promptUpdated := false
		for i, envVar := range env {
			if strings.HasPrefix(envVar, "PROMPT=") {
				// Extract the current PROMPT value
				currentPrompt, _ := strings.CutPrefix(envVar, "PROMPT=")
				// Prepend our indicator
				newPrompt := fmt.Sprintf("PROMPT=(git-go-patch) %s", currentPrompt)
				env[i] = newPrompt
				promptUpdated = true
				break
			}
		}

		// If PROMPT wasn't found, add a default one
		if !promptUpdated {
			env = append(env, "PROMPT=(git-go-patch) $P$G")
		}
	}

	// Add an environment variable to indicate we're in git-go-patch mode
	env = append(env, "GIT_GO_PATCH_INTERACTIVE=1")

	// Start the interactive shell in the submodule directory
	cmd := exec.Command(userShell)
	cmd.Dir = goDir
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Env = env

	fmt.Printf("\nStarting shell in %s...\n", goDir)
	fmt.Printf("Current working directory will be: %s\n", goDir)
	fmt.Printf("Automatically starting 'git rebase -i %s'...\n\n", since)

	// Start the rebase automatically in the background
	// We'll use a shell command to run the rebase and then keep the shell open
	var shellCmd string
	var shellArgs []string

	if runtime.GOOS == "windows" {
		shellCmd = userShell
		shellArgs = []string{"/k", fmt.Sprintf("git rebase -i %s", since)}
	} else {
		shellCmd = userShell
		// Use shell -c to run the rebase command and then start an interactive shell
		shellArgs = []string{"-c", fmt.Sprintf("git rebase -i %s; exec %s", since, userShell)}
	}

	cmd = exec.Command(shellCmd, shellArgs...)
	cmd.Dir = goDir
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Env = env

	err := cmd.Run()
	shellExitedWithError := err != nil

	if shellExitedWithError {
		fmt.Printf("\nShell exited with error: %v\n", err)
		fmt.Printf("Exit code indicates to skip automatic extraction.\n")
	} else {
		fmt.Printf("\nShell session completed successfully.\n")
	}

	// Skip extract if user requested it via flag or if shell exited with non-zero code
	if skipExtract || shellExitedWithError {
		if skipExtract {
			fmt.Printf("\nSkipping automatic extraction as requested via -skip-extract flag.\n")
		} else {
			fmt.Printf("\nSkipping automatic extraction due to non-zero shell exit code.\n")
		}
		fmt.Printf("Remember to run 'git go-patch extract' manually when you're ready.\n")
		return nil
	}

	// Now automatically run extract
	fmt.Printf("\nAutomatically running 'git go-patch extract' to save your changes...\n")

	// Call extract internally instead of shelling out
	extractParseFunc := func() error { return nil } // No-op since we don't need to parse flags
	if err := handleExtract(extractParseFunc); err != nil {
		return fmt.Errorf("failed to run extract: %w", err)
	}

	fmt.Printf("\n%s=== Shell session completed successfully! ===%s\n",
		"\033[1;32m", "\033[0m") // Green bold text
	fmt.Printf("Your changes have been extracted to patch files.\n")

	return nil
}

func checkForOngoingGitOperations(gitDir string) error {
	// Check if git is in the middle of a rebase
	rebaseHeadFile := filepath.Join(gitDir, ".git", "rebase-merge", "head-name")
	if _, err := os.Stat(rebaseHeadFile); err == nil {
		return fmt.Errorf("git is currently in the middle of a rebase - complete or abort it first with 'git rebase --continue' or 'git rebase --abort'")
	}

	// Check for interactive rebase
	rebaseInteractiveFile := filepath.Join(gitDir, ".git", "rebase-apply", "applying")
	if _, err := os.Stat(rebaseInteractiveFile); err == nil {
		return fmt.Errorf("git is currently in the middle of an interactive rebase - complete or abort it first")
	}

	// Check if git is in the middle of a merge
	mergeHeadFile := filepath.Join(gitDir, ".git", "MERGE_HEAD")
	if _, err := os.Stat(mergeHeadFile); err == nil {
		return fmt.Errorf("git is currently in the middle of a merge - complete or abort it first with 'git merge --continue' or 'git merge --abort'")
	}

	// Check if git is in the middle of a cherry-pick
	cherryPickHeadFile := filepath.Join(gitDir, ".git", "CHERRY_PICK_HEAD")
	if _, err := os.Stat(cherryPickHeadFile); err == nil {
		return fmt.Errorf("git is currently in the middle of a cherry-pick - complete or abort it first with 'git cherry-pick --continue' or 'git cherry-pick --abort'")
	}

	return nil
}

func warnIfOutsideSubmodule(submoduleDir string) {
	const unexpected = "WARNING: Unexpected error while checking if working dir is inside submodule: "

	wd, err := os.Getwd()
	if err != nil {
		fmt.Printf("%vunable to get working dir: %v\n", unexpected, wd)
		return
	}

	rel, err := filepath.Rel(submoduleDir, wd)
	if err != nil {
		fmt.Printf("%vunable to calculate relative path from %#q to %#q: %v", unexpected, submoduleDir, wd, err)
		return
	}
	invRel, err := filepath.Rel(wd, submoduleDir)
	if err != nil {
		fmt.Printf("%vunable to calculate inverse relative path from %#q to %#q: %v", wd, unexpected, submoduleDir, err)
		return
	}

	// Handle ".." and "../foo" separately to properly handle "..foo" special case.
	if rel == ".." || strings.HasPrefix(rel, filepath.FromSlash("../")) {
		fmt.Printf("\nWARNING: The current working directory is not inside the submodule!\n"+
			"  Working dir %#q relative to %#q is %#q.\n"+
			"  To continue the rebase process in this terminal with Git commands:\n\n"+
			"    cd %v\n",
			wd, submoduleDir, rel, invRel)
	}
}
