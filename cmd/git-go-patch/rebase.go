// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/microsoft/go-infra/executil"
	"github.com/microsoft/go-infra/subcmd"
)

func init() {
	subcommands = append(subcommands, subcmd.Option{
		Name:    "rebase",
		Summary: "Run 'git rebase -i' on the commits created by 'apply'.",
		Description: `

This command rebases the commits applied to the submodule based on patch files. It uses the HEAD
commit recorded by "apply" as the base commit.

You can use this command to apply fixup and squash commits generated by the "git commit" args
"--fixup" and "--squash". To do this, configure Git using "git config --global rebase.autoSquash 1"
before running this command.

Be aware that editing earlier patch files may cause conflicts with later patch files.
` + repoRootSearchDescription,
		Handle: handleRebase,
	})
}

func handleRebase(p subcmd.ParseFunc) error {
	if err := p(); err != nil {
		return err
	}

	config, err := loadConfig()
	if err != nil {
		return err
	}
	_, goDir := config.FullProjectRoots()

	since, err := readStatusFile(config.FullPrePatchStatusFilePath())
	if err != nil {
		return err
	}

	cmd := exec.Command("git", "rebase", "-i", since)
	cmd.Stdin = os.Stdin
	cmd.Dir = goDir

	if err := executil.Run(cmd); err != nil {
		return err
	}

	if err := warnIfOutsideSubmodule(goDir); err != nil {
		// Just log for diagnosis, this warning isn't critical.
		fmt.Printf("Unexpected error while checking wd: %v\n", err)
	}
	return nil
}

func warnIfOutsideSubmodule(submoduleDir string) error {
	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("unable to get working dir: %v", wd)
	}

	rel, err := filepath.Rel(submoduleDir, wd)
	if err != nil {
		return fmt.Errorf("unable to calculate relative path from %#q to %#q: %v", submoduleDir, wd, err)
	}
	invRel, err := filepath.Rel(wd, submoduleDir)
	if err != nil {
		return fmt.Errorf("unable to calculate inverse relative path from %#q to %#q: %v", wd, submoduleDir, err)
	}

	// Handle ".." and "../foo" separately to properly handle "..foo" special case.
	if rel == ".." || strings.HasPrefix(rel, filepath.FromSlash("../")) {
		fmt.Printf("\nWARNING: The current working directory is not inside the submodule!\n"+
			"  Working dir %#q relative to %#q is %#q.\n"+
			"  To continue the rebase process in this terminal with Git commands:\n\n"+
			"    cd %v\n",
			wd, submoduleDir, rel, invRel)
	}
	return nil
}
