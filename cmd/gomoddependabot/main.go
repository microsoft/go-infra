// Copyright (c) Microsoft Corporation.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"slices"
	"sort"
	"strings"

	"github.com/microsoft/go-infra/gitcmd"
)

func main() {
	log.SetPrefix("gomoddependabot: ")
	log.SetFlags(0)

	if err := run(); err != nil {
		log.Printf("error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	exitCodeFlag := flag.Bool("exit-code", false, "if set, do not write any updates; instead exit 1 (for use in CI)")

	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "Usage: %s [flags]\n", os.Args[0])
		flag.PrintDefaults()
		fmt.Fprintln(
			flag.CommandLine.Output(),
			"Update .github/dependabot.yml to include all Go modules tracked in the current Git repository. "+
				"Each module is treated as a group, so updates are bundled as much as possible, reducing PR volume.")
	}
	flag.Parse()

	dependabotPath := ".github/dependabot.yml"
	oldData, err := os.ReadFile(dependabotPath)
	if err != nil {
		return fmt.Errorf("read existing yml: %v", err)
	}
	oldData = bytes.ReplaceAll(oldData, []byte{'\r', '\n'}, []byte{'\n'})

	lines := strings.Split(string(oldData), "\n")

	const beginGeneratedComment = "  # Following lines generated by gomoddependabot; DO NOT EDIT."

	// Trim trailing newlines to simplify logic. Note that newlines before the
	// generated comment are preserved.
	for len(lines) > 0 && strings.TrimSpace(lines[len(lines)-1]) == "" {
		lines = lines[:len(lines)-1]
	}
	// Remove lines that specify go.mod files as JSON (subset of YAML), and the
	// generated code announcement.
	lines = slices.DeleteFunc(lines, func(line string) bool {
		if line == beginGeneratedComment {
			return true
		}
		element, ok := strings.CutPrefix(line, "  - ")
		if !ok {
			return false
		}
		var entry dependabotJSONEntry
		err := json.Unmarshal([]byte(element), &entry)
		return err == nil
	})

	var newLines []string

	modules, err := findGoModuleDirs(".")
	if err != nil {
		return fmt.Errorf("find modules: %v", err)
	}
	for _, m := range modules {
		entry := dependabotJSONEntry{
			PackageEcosystem: "gomod",
			Directory:        m,
			Groups: map[string]any{
				"all": map[string]any{},
			},
		}
		entry.Schedule.Interval = "daily"

		element, err := json.Marshal(entry)
		if err != nil {
			return fmt.Errorf("marshal entry: %v", err)
		}
		newLines = append(newLines, fmt.Sprintf("  - %s", element))
	}
	slices.Sort(newLines)
	newLines = append([]string{beginGeneratedComment}, newLines...)
	newLines = append(newLines, "")

	newData := []byte(strings.Join(append(lines, newLines...), "\n"))

	if bytes.Equal(oldData, newData) {
		// Up to date.
		log.Printf("%q already up to date.\n", dependabotPath)
		return nil
	}
	if *exitCodeFlag {
		return fmt.Errorf("%q is out of date", dependabotPath)
	}

	if err := os.WriteFile(dependabotPath, newData, 0o644); err != nil {
		fmt.Fprintf(os.Stderr, "gendependabot: write: %v\n", err)
		os.Exit(2)
	}
	log.Printf("Updated %s.\n", dependabotPath)
	return nil
}

type dependabotJSONEntry struct {
	PackageEcosystem string `json:"package-ecosystem"`
	Directory        string `json:"directory"`
	Schedule         struct {
		Interval string `json:"interval"`
	} `json:"schedule"`
	Groups                map[string]any `json:"groups"`
	OpenPullRequestsLimit int            `json:"open-pull-requests-limit,omitempty"`
}

func findGoModuleDirs(root string) ([]string, error) {
	// Use 'git ls-tree --name-only -r HEAD' to only find go.mod files that are
	// included in the repo. This avoids problems with submodules and temporary
	// data that's in .gitignore files.
	var dirs []string
	out, err := gitcmd.CombinedOutput(
		root,
		"ls-tree",
		"--name-only",
		"-r",
		"-z", // null-terminate
		"HEAD",
	)
	if err != nil {
		return nil, err
	}
	for line := range strings.SplitSeq(out, "\x00") {
		// Normalize paths like "go.mod" and "foo/bar/go.mod" to what dependabot
		// expects: "/" and "foo/bar" respectively.
		line = "/" + line
		if pre, ok := strings.CutSuffix(line, "/go.mod"); ok {
			if pre == "" {
				pre = "/"
			}
			dirs = append(dirs, pre)
		}
	}
	sort.Strings(dirs)
	return dirs, nil
}
