// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// Package pipelineymlgen implements github.com/microsoft/go-infra/cmd/pipelineymlgen.
package pipelineymlgen

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"go.yaml.in/yaml/v4"
)

var ErrFileDiffers = errors.New("generated file differs from existing file")

// Template function regex to find ${ ... } expressions.
var templateExprRegex = regexp.MustCompile(`\$\{ +(.*?) +\}`)

// Run the given command. If f.Check is true, may return ErrFileDiffers.
func Run(f *CmdFlags, args ...string) error {
	// Discover files to process
	files, err := f.TargetFiles(args)
	if err != nil {
		return fmt.Errorf("failed to discover files: %w", err)
	}

	for _, file := range files {
		processErr := processFile(f, file)
		if processErr != nil {
			err = errors.Join(err, fmt.Errorf("processing %#q: %w", file, processErr))
		}
	}
	return err
}

func processFile(f *CmdFlags, file string) error {
	docs, err := readYAMLFileDocs(file)
	if err != nil {
		return fmt.Errorf("failed to read YAML file: %w", err)
	}

	rootState := &EvalState{
		File: file,
		Data: map[string]any{},
	}
	// Only evaluate the config so far. We can't actually evaluate the content:
	// it might strongly depend on data that is only passed into the template by
	// "output" objects or by other templates using inlinetemplate.
	config, content, err := rootState.EvalFileConfig(docs)
	if err != nil {
		return fmt.Errorf("failed to evaluate: %w", err)
	}

	// Figure out if we need to evaluate the content and write it to an output.
	var outputs []OutputConfig
	if config != nil && config.Config != nil {
		if output := config.Config.Output; output != nil {
			if len(output.Entries) > 0 {
				outputs = config.Config.Output.Entries
			} else if output.Self {
				outputs = append(outputs, OutputConfig{
					File: strings.TrimSuffix(filepath.Base(file), ".gen.yml") + ".yml",
					Data: nil,
				})
			}
		}
	}

	// Add a header indicating this file is generated, and try to preserve any
	// header at the top of the gen.yml file. (The original header comment is
	// not encoded in the yaml.Node tree.)
	header, err := readFileHeaderCommentLines(file)
	if err != nil {
		return fmt.Errorf("failed to read header comment: %w", err)
	}
	if header != "" {
		header = "\n" + header
	}
	content.HeadComment =
		"# Code generated by pipelineymlgen; DO NOT EDIT.\n" +
			"# Origin file: " + filepath.Base(file) + "\n" +
			header +
			content.HeadComment

	for _, out := range outputs {
		// Only generate to local paths.
		if !filepath.IsLocal(out.File) {
			return fmt.Errorf("output file %#q is not a local path", out.File)
		}

		outPath := filepath.Join(filepath.Dir(file), out.File)

		if f.Clean {
			if err := os.Remove(outPath); err != nil {
				if !errors.Is(err, os.ErrNotExist) {
					return fmt.Errorf("failed to remove %s: %w", outPath, err)
				}
				fmt.Printf("File does not exist, nothing to remove: %s\n", outPath)
			} else {
				fmt.Printf("Removed generated file: %s\n", outPath)
			}
			continue
		}

		outputState := *rootState
		outputState.MergeData(out.Data)
		outputState.MergeData(map[string]any{"output": out.File})

		resultNode, err := outputState.evalFileWithConfig(config, content)
		if err != nil {
			return fmt.Errorf("failed to evaluate output for %s: %w", outPath, err)
		}

		var out bytes.Buffer
		err = writeYAMLDoc(&out, resultNode)
		if err != nil {
			return fmt.Errorf("failed to encode output YAML for %s: %w", outPath, err)
		}

		if f.Check {
			// Instead of writing, check if the file exists and matches.
			existing, err := os.ReadFile(outPath)
			if err != nil && !errors.Is(err, os.ErrNotExist) {
				return fmt.Errorf("failed to read existing %s: %w", outPath, err)
			}

			// Best effort to normalize line endings for Windows checkouts.
			existing = bytes.ReplaceAll(existing, []byte("\r\n"), []byte("\n"))

			if string(existing) != out.String() {
				return fmt.Errorf("%w: %s", ErrFileDiffers, outPath)
			}
			fmt.Printf("File content same as fresh generation: %s\n", outPath)
			continue
		}

		if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
			return fmt.Errorf("failed to create directory for %s: %w", outPath, err)
		}
		fmt.Printf("Wrote: %s\n", outPath)
		if err := os.WriteFile(outPath, out.Bytes(), 0o644); err != nil {
			return fmt.Errorf("failed to write %s: %w", outPath, err)
		}
	}
	return nil
}

// readFileHeaderCommentLines returns all lines from file that are comments or
// blank lines until reaching the first non-comment line. Trims trailing (and
// leading) whitespace from the result.
func readFileHeaderCommentLines(file string) (string, error) {
	f, err := os.Open(file)
	if err != nil {
		return "", err
	}
	defer f.Close()

	var sb strings.Builder
	s := bufio.NewScanner(f)
	for s.Scan() {
		line := s.Text()
		if strings.HasPrefix(line, "#") {
			sb.WriteString(line + "\n")
		} else if strings.TrimSpace(line) == "" {
			sb.WriteString("\n")
		} else {
			break
		}
	}
	if err := s.Err(); err != nil {
		return "", fmt.Errorf("failed to read file %s: %w", file, err)
	}
	return strings.TrimSpace(sb.String()), nil
}

type ConfigurationDoc struct {
	Config *Configuration `yaml:"pipelineymlgen"`
}

type Configuration struct {
	Data   map[string]any   `yaml:"data"`
	Output *OutputDirective `yaml:"output"`
}

type OutputDirective struct {
	Entries []OutputConfig
	Self    bool
}

// UnmarshalYAML converts the YAML representation of the output directive into a
// structured OutputDirective value. Supports `output: self` as a shorthand for
// writing the evaluated template back to its own non-gen path.
func (o *OutputDirective) UnmarshalYAML(value *yaml.Node) error {
	if value == nil {
		return nil
	}

	switch value.Kind {
	case yaml.ScalarNode:
		if value.Tag == "!!null" || value.Value == "" {
			return nil
		}
		if strings.EqualFold(value.Value, "self") {
			o.Self = true
			return nil
		}
		return fmt.Errorf("unsupported output value %q", value.Value)

	case yaml.SequenceNode:
		var outputs []OutputConfig
		if err := value.Decode(&outputs); err != nil {
			return fmt.Errorf("failed to decode output sequence: %w", err)
		}
		o.Entries = outputs
		return nil

	default:
		return fmt.Errorf("unsupported output node kind: %v", value.Kind)
	}
}

// OutputConfig represents a single output configuration.
type OutputConfig struct {
	File string         `yaml:"file"`
	Data map[string]any `yaml:"data"`
}
